1.
C, E.
 To construct an instance of a sub class, its super class needs need to be constructed first. Since an instance can only be created via a constructor, some constructor of the super class has to be invoked. Instead of calling super(...) you can also call another constructor of the base class in the first line (as given in choice B(int z ) { this(z, z); } ). Here, this(int, int) is called in the first line which in turn calls super(int). So the super class A is correctly instantiated.

2.
F.
There is no problem with the code. It is perfectly valid for a sub-interface to override a default method of the base interface. A class that implements an interface can also override a default method. It is valid for MyHouse to say that it implements Bungalow as well as House even though House is redundant because Bungalow is a House anyway. 

3.
B, C, D
While accessing a method or variable, the compiler will only allow you to access a method or variable that is visible through the class of the reference.  When you try to use f.name, the class of the reference f is Flyer and Flyer has no field named "name", thus, it will not compile. But when you cast f to Bird (or Eagle), the compiler sees that the class Bird (or Eagle, because Eagle inherits from Bird) does have a field named "name" so ((Eagle)f).name or ((Bird)f).name will work fine.  f.getName() will work because Flyer does have a getName() method.

4.
C
a*10/4.0; generates a double so, A2's m1() cannot return an int. (It will need a cast otherwise: return (int) (a*10/4.0);)
The return type should be same for overridden and overriding method, or a more specific for the overriding method when talking about references. A2 has to return a double, so A has to return a double too. If A2 could return an int, then A must to be int (primitive covariant return types are not allowed

5.
A, D
B and C are not correct lambdas. D is right because add() returns true if the element was added to the arraylist, which is the case.

6.
E.
Remember that static and instance variables are automatically assigned a value even if you don't initialize them explicitly but local variables must be initialized explicitly before they are used. calc method declares local variables coupon, offset, and base but does not assign them a value. Having uninitialized variables itself is not a problem. So there is no compilation error at //3. However, using them before they are initialized is a problem and therefore the compiler flags an error at //5.

7.
B
Iteration 1: i=1 j=10 Iteration 2: i=2 j=9 Iteration 3: i=3 j=8 Iteration 4: i=4 j=7 Iteration 5:i=5 j=6

8.
D.
Even if // 1 is enclosed in a try block, the method still has throws Exception in its declaration, which will force the caller of this method to either declare Exception in its throws clause or put the call within a try block. Any checked exceptions must either be handled using a try block or the method that generates the exception must declare that it throws that exception. In this case, doA() declares that it throws Exception. doB() is calling doA but it is not handling the exception generated by doA(). So, it must declare that it throws Exception. Now, the main() method is calling doB(), which generates an exception (due to a call to doA()). Therefore, main() must also either wrap the call to doB() in a try block or declare it in its throws clause.

9.
C.
Remember that a String once created cannot be changed. Therefore, when you call replace or concat methods on a String, a new String object is created. The old String remains as it is. Here, the first call to concat returns a new String object containing "Input value must be smaller than X" and it is assigned back to msg. The original String referred to by msg is now lost (i.e. there is no reference to it anymore). The first call to replace also creates a new String object but it is not assigned to any reference and is therefore lost and msg keeps pointing to the same String object. The same thing happens to the second call to concat. It create a new String object but it is not assigned back to msg, therefore, msg keeps pointing to the same object i.e. "Input value must be smaller than X" 


10
A.
A boolean cannot be used for a switch statement. It needs an integral type, an enum, or a String.

11.
C
When a Noobs object is created, a MyException object is also created. Therefore a total of 4 objects are created. The line Noobs c = a; just assigns an existing Noobs object to c. No new object is created.

12.
D.
There are multiple concepts at play here: 
1. All the wrapper objects are immutable. So when you do obj++, what actually happens is something like this: obj = new Integer( obj.intValue()  + 1);   
 2.val1++ uses post-increment operator, which implies that you note down the current value of val1, increment it, and then pass the original noted down value to the method testInts. Thus, the reference value of Integer 5 is passed to testInts. But val1 is set to point to a new Integer object containing 6. ++val2 uses pre-increment operator, which implies that you first increment val2 and then pass the incremented value. Therefore, val2 is incremented to 10 and then 10 is passed to the method testInts.  
3. Java uses pass by value semantics in method calls. In case of primitive variables, their values are passed, while in case of Objects, their reference values are passed.  Thus, when you assign a different object to reference variable in a method, the original reference variable that was passed from the calling method still points to the same object that it pointed to before the call. In this question, therefore, val1 in main still points to 6 after the call to testInts returns.

13.
A
Here, we have four overloaded probe methods but there is no probe method that takes a double parameter. However, a double will be boxed into a Double and class Double extends Number. Therefore, a Double can be passed to the method that takes Number. A Double can also be passed to a method that takes Object, but Number is more specific than Object therefore probe(Number ) will be called.

14
C
Always remember: Instance methods are overridden and variables are hidden. Which method is invoked depends on the class of the actual object, while which field is accessed depends on the class of the variable. Here, b refers to an object of class Beta so b.getH() will always call the overridden (subclass's method). However, the type of reference of b is Baap. so b.h will always refer to Baap's h. Further, inside Beta's getH(), Beta's h will be accessed instead of Baap's h because you are accessing this.h ('this' is implicit) and the type of this is Beta.  The class of bb, on the other hand, is Beta. Thus, bb.h will always refer to Beta's h.

15.
F.
"static import" is not valid, has to be "import static". And static imports import methods or variables that are statics, not the class.

16.
F.
process is package-protected (because has no access modifier). Therefore, can not be accessed from a different package.

